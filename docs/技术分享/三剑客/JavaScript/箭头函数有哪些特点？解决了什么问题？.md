---
title: 箭头函数有哪些特点？解决了什么问题？
---

# 箭头函数有哪些特点？解决了什么问题？

## 箭头函数的特点
1. 更简洁的语法，例如：
   - 只有一个形参就不需要用括号括起来。
   - 如果函数体只有一行，就不需要放到一个块中。
   - 如果 **return** 语句是函数体内唯一的语句，就不需要 **return** 关键字。
2. 箭头函数没有自己的 **this**，**arguments**，**super**。
3. 箭头函数 **this** 只会从自己的作用域链的上一层继承 **this**。

## 箭头函数解决了什么问题？
- 箭头函数的语法比函数表达式更简洁。
- 箭头函数可以解决 *this* 指向问题。箭头函数不会创建自己的 *this*，它只会从自己当前作用域的向上一层继承 *this*。所以当遇到需要使用外层 *this* 指向需求的时候，使用这个就可以非常方便的解决
- 但是最根本的原因是解决了**函数二义性**的问题。

## 扩展 - 什么是函数二义性？
在一门支持面向对象的语言中，函数往往存在两个层面的含义，一个是指令序列(一件事，先做什么在做什么)，一个是创建实例(new 调用)。

这两个层面意思不一样，按理来说应该在语法层面区分开来，而在过去的 js 中并没有实现这种区分，也是 js 的设计缺陷，这样就会产生一些误会。

比如看到一个函数的时候是 foo() 调用还是 new foo() 这样调用，为了解决这个问题，我们有一种约定俗成的规范，如果这个函数是一个**构造函数**，需要被 *new* 调用的话，就会给这个函数的**首字母进行大写**，而构造函数首字母大写也并不是一个**强约束**，依然可以被直接调用。

所以为了解决这个**二义性问题**，ES6 通过引用了 **class** 和 **箭头函数** 来消除，使用 class 创建实例，使用箭头函数完成指令序列，所以 class 和箭头函数不仅仅是为了书写代码的方便，更加重要的原因就是消除了**函数二义性问题**。

## 扩展 - 根据二义性来解析箭头函数和普通函数
了解这一点就可以知道为什么箭头函数不能使用 new 调用，也不存在 this 了，为什么？因为箭头函数表示的指令序列，和实例无关，已经脱离了面向对象的范畴，而 this 是来自于面向对象里面的概念，所以不会存在 this，而箭头函数没有原型也是同理，原型和实例是密切相关的，是实现面向对象的手段。

也同样可以解释为什么没有 `arguments `，准确点说不是没有，是没有自己的 arguments、this、new.target，全都来自上层作用域，示例代码如下：
```js
function foo() {
	setTimeout(() => {
		console.log('args:', arguments) // args: [Arguments] { '0': 1, '1': 2, '2': 3}
	}, 1)
}
foo(1, 2, 3)
```
