---
title: 首屏加载优化
---

# 首屏加载优化

### 一、资源体积与内容优化
1. **代码压缩与冗余清理**  
   - **移除未使用的依赖**：通过工具（如 `webpack-bundle-analyzer`）分析包体积，剔除冗余第三方库（如未使用的图表库、编辑器等）。  
   - **代码压缩**：使用 UglifyJS、Terser 压缩 JS/CSS 代码，去除空格、注释和混淆变量名，减少文件体积。  
   - **Tree Shaking**：通过 ES6 模块化语法实现按需导出，避免打包未引用的代码。

2. **图片优化**  
   - **格式选择**：优先使用 WebP（体积比 JPEG/PNG 小 30% 以上），低端机型可降级为 JPEG/PNG。  
   - **压缩处理**：集成 `image-webpack-loader` 到构建流程，自动化压缩图片，或手动使用 TinyPNG 等工具。  
   - **懒加载**：通过 `Intersection Observer` 监听图片进入视口再加载，减少首屏请求数。

3. **代码分割与分包**  
   - **路由懒加载**：Vue/React 项目使用动态 `import()` 拆分路由组件，按需加载。  
   - **拆分 Vendor**：将第三方依赖拆分为独立 chunk，避免单文件过大（如拆分 Ant Design 未使用的组件）。

---

### 二、加载策略优化
1. **关键资源优先加载**  
   - **内联关键 CSS**：将首屏渲染必需的 CSS 内联到 HTML 头部，避免因外部 CSS 加载阻塞渲染。  
   - **异步加载非关键 JS**：通过 `async` 或 `defer` 属性异步加载非首屏脚本（如统计代码）。

2. **预加载与预请求**  
   - **资源预加载**：利用 `<link rel="preload">` 提前加载首屏必需资源（如字体、核心 JS）。  
   - **容器预建**（App 场景）：在空闲时预初始化 WebView 容器，节省首次打开耗时（减少 100-300ms）。

3. **缓存策略**  
   - **强缓存与协商缓存**：通过 `Cache-Control` 设置静态资源缓存时间，减少重复请求。  
   - **离线包策略**：App 内将资源预下载到本地，通过拦截请求加载本地文件（弱网下加载时间可缩短至 100ms 以内）。

---

### 三、网络性能优化
1. **CDN 加速与智能调度**  
   - 静态资源部署至 CDN，利用边缘节点缩短传输路径，并通过 DNS 预解析优化建连速度。  
   - 结合用户地理位置和网络状况动态选择最优 CDN 节点。

2. **服务端优化**  
   - **开启 Gzip/Brotli 压缩**：减少传输体积（如文本资源压缩率可达 70%）。  
   - **服务端渲染（SSR）**：在服务端生成首屏 HTML，避免客户端渲染白屏时间（适合内容固定页面）。  
   - **HTTP/2 协议**：支持多路复用，提升并发请求效率。

---

### 四、客户端与工程化优化
1. **构建工具配置**  
   - **分包策略**：Webpack 配置 `splitChunks` 按模块使用频率拆分代码。  
   - **资源分级下发**：根据机型性能下发不同质量的资源（如低端机使用 1x 图，高端机用 3x 图）。

2. **Hybrid 混合方案**  
   - 将 HTML/CSS/JS 内置到 App，通过 `file://` 协议加载，结合 Ajax 动态获取数据。  
   - **预取数据**：在列表页预加载详情页内容，用户跳转时直接展示。

---

### 五、用户体验优化
1. **视觉反馈**  
   - 使用骨架屏（Skeleton Screen）或 Loading 动画缓解用户等待感知。  
   - 渐进式图片加载：先加载低分辨率图片，再替换为高清图。

2. **性能监控与分析**  
   - **Lighthouse/Web Vitals**：定期评测首屏指标（FCP、Speed Index、TTI）。  
   - **Performance 面板**：分析主线程阻塞、长任务等性能瓶颈。

---


### 六、首屏加载指标细化
- FP（First Paint）：首次绘制，浏览器开始绘制页面，绘制任何文本、图像、SVG等。
- FCP（First Contentful Paint）：首次内容绘制，浏览器绘制首次有内容的绘制，比如文本、图片、svg等。
- FMP（First Meaningful Paint）：首次有意义绘制，页面主要内容出现在屏幕上。
- LCP（Largest Contentful Paint）：最大内容绘制，也就是页面加载过程中，那块内容渲染最复杂，渲染时长最久。

FP 到 FCP 中间主要是 SPA 应用的 js 执行，如果太慢会导致页面空白时间过长，影响用户体验。

### 七、用户使用体验指标
1. **INP（Interaction to Next Paint）**  
**全称**：交互至下一次渲染  
**定义**：衡量用户与页面交互（如点击、输入）后，到浏览器完成下一次渲染的时间。它覆盖整个页面生命周期中所有交互的响应延迟，而非仅首次交互。  
**计算方式**：统计所有用户交互的延迟时间，取最长延迟的 98% 分位值（忽略极端值）。  
**优化目标**：  
- **≤ 200ms**：响应速度良好  
- **200ms~500ms**：需要改进  
- **> 500ms**：响应速度差  
**重要性**：INP 预计将取代 FID（首次输入延迟），成为 Google Core Web Vitals 的交互体验核心指标，因为它更全面反映页面响应性。

---

2. **TTI（Time to Interactive）**  
**全称**：首次可交互时间  
**定义**：从页面加载开始到主线程空闲足够长时间（5秒无长任务和网络请求）且能快速响应用户输入的时间点。  
**关键条件**：  
- 在 FCP（首次内容绘制）之后开始计算；  
- 主线程连续 5 秒无长任务（执行超过 50ms 的任务）；  
- 网络请求不超过 2 个。  
**优化目标**：  
- **≤ 3.8 秒**：优秀（绿色）  
- **3.9~7.3 秒**：需优化（橙色）  
- **> 7.3 秒**：较差（红色）  
**应用场景**：用于评估页面加载后何时真正可用，避免用户看到内容却无法操作。

---

3. **TBT（Total Blocking Time）**  
**全称**：总阻塞时间  
**定义**：在 FCP 到 TTI 之间，主线程因执行长任务（超过 50ms）而被阻塞的时间总和。  
**计算方式**：每个长任务的阻塞时间 = 任务总时长 - 50ms，所有长任务的阻塞时间累加。  
**优化目标**：控制在 **200ms 以内**。  
**影响**：TBT 高会导致用户交互卡顿，例如点击按钮无反应。

---

4. **CLS（Cumulative Layout Shift）**  
**全称**：累计布局偏移  
**定义**：衡量页面元素在加载过程中意外移动的视觉稳定性。例如图片加载后挤压下方文本、广告插入导致内容下移等。  
**计算方式**：  
- **偏移分数 = 影响面积比例 × 位移距离比例**  
- 取整个页面生命周期中所有偏移分数的最大值。  
**优化目标**：**≤ 0.1**  
**注意**：突发性偏移（间隔 <1 秒的多次偏移）会被合并为“会话窗口”，取窗口内累计最大值。
