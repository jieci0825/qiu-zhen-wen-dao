---
title: 下列代码的执行结果
---

# 下列代码的执行结果

## case1
```js
foo(typeof a)
function foo(p) {
	console.log(this)
	console.log(p)
	console.log(typeof b)
	let b = 0
}
```

:::details 答案与解析
**答案**：
```
globalThis 
'undefined' 
ReferenceError: Cannot access 'b' before initialization
```

**解析**：

**console.log(this)**： 输出 globalThis 是因为函数独立调用，this 指向全局对象。

**console.log(p)**： 输出 'undefined' 是因为 *foo(typeof a)* 调用时 typeof a 返回得到的结果是 'undefined'，因此形参 p 为 'undefined'。

**console.log(typeof b)**： b 使用 let 定义，let 定义的变量无法提前访问。

:::

## case2
```js
class Foo {
    constructor(arr) {
        this.arr = arr
    }
    bar(n) {
        return this.arr.slice(0, n)
    }
}
var f = new Foo([0, 1, 2, 3])
console.log(f.bar(1))
console.log(f.bar(2).splice(1, 1))
console.log(f.arr)
```

:::details 答案与解析
**答案**：
```
[0]
[1]
[0, 1, 2, 3]
```

**解析**：

**console.log(f.bar(1))**：使用 slice 方法截取数组但是不破坏原数组。

**console.log(f.bar(2).splice(1, 1))**：splice 方法的返回值是**一个包含了删除的元素的数组**。，f.bar(2) 得到 [0, 1]，splice(1, 1) 会删除数组中的 1，并返回。

**console.log(f.arr)**：上述都没有破坏原数组，所以还是原封不动。

:::