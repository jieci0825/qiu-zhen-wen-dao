---
title: 隐式转换
---

# 隐式转换

**题目**
```js
const s = '123'
s.c = 4
s.d = 5

const [a, b] = s
const { c, d } = s

console.log(a, b, c, d)
```
:::details 答案
**输出**
```
1 2 undefined undefined
```

**分析**
1. 关于 `const s = '123'` 应该无需解释的。
2. 那么 `s.c = 4` 实际发生了事情呢？
    - 试图在字符串 s 上添加一个名为 c 的属性，并将其值设置为 4。
    - 但字符串是原始类型，它们本身不可以有属性，所以，在执行的时候会创建一个**临时的字符串包装对象**，然后在这个对象上添加属性 c，所以实际添加的属性在临时对象上，而不是字符串 s 上。而这个字符串也会因为垃圾回收机制被销毁。
3. `s.d = 5` 同理。
4. `const [a, b] = s` 也比较好理解，平常字符串在使用中，也是可以通过索引获取某一个字符的，比如 s[0]。而字符串也是可迭代的，所以在解构的过程中，字符串中的每个字符都会被当作数组元素处理，或者说只要是一个可迭代对象，就可以被解构赋值。
5. 在执行 `const { c, d } = s` 时，JS 试图从 s 中提取 c 和 d 这两个属性。正常情况下，如果 s 是一个对象，JS 会查找并提取这些属性的值。但是，s 是一个字符串，它本质上并没有 c 和 d 这两个属性（因为字符串是原始类型，不能有自定义属性）。所以还是同理，进行对象解构时会尝试将字符串 s 转换为一个临时的 **String 对象**，也就是通过 new String(s) 创建一个对象。但是这个临时对象并不具备 c 和 d 这两个属性，所以解构赋值的结果是 undefined。
:::