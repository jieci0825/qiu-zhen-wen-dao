---
title: TCP 三次握手和四次挥手
---

# TCP 三次握手和四次挥手

## 三次握手

### 过程
三次握手的过程类似于寄快递场景：
> - A 想给 B 寄一个包裹，但是 A 怕包裹发出去了，但是 B 已经不在了，无法正常收到包裹，所以先问一下 B 是否还在原来的地方，可以正常收包裹吗？
> - 而 B 也担心 A 说的是一句玩笑话，导致徒留原地，浪费时间，所以反问了一句 A，我在，但是你确定要给我寄包裹吗？
> - A 确认了 B 的信息，说道，放心吧，我确定要给你寄包裹，双方约定达成。
> - 然后就开始寄包裹了。

上面是一个用一个场景做出的比喻，但是实际上三次握手的过程是：
> - **第一次握手**：客户端发送 syn(synchronize) 包（syn=x）到服务器，并进入 SYN_SEND 状态，等待服务器确认。
> - **第二次握手**：服务器收到 syn 包，必须确认客户的 SYN（ack=x+1），同时自己也发送一个 SYN 包（syn=y），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态。
> - **第三次握手**：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=y+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。

:::tip
SYN 标志位数置1，表示建立 TCP 连接；ACK 标志表示验证字段。

以上动作发送的包中没有任何数据，等三次握手完成后客户端与服务器才正式开始传送数据。并且理想状态下，TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。
:::

过程如图所示：

<img src="https://cos.coderjc.cn/blog/image-20250121104320709.png" alt="image-20250121104320709" />

### 为什么需要三次握手？
为什么需要握手呢？
> 客户端和服务器的通信前需要连接，而**握手**的作用就是为了证明双方都具备发送和接收消息的能力，这就是握手的目的。


还是使用寄快递的场景，寄一个快递的时候 A 说一句我给你寄，B 回复你寄吧，我就在这里。这样好像也可以，但是此时 B 无法确认 A 是否收到了自己回复，那么 B 的心里必然是忐忑的，所以需要 A 再来一次确定的回复，这样 B 才能放心等待包裹。通过这样的一个过程，A 和 B 才能达成这个约定。

那么代入 TCP 中，为了达成握手的目的，使用了三次握手的方案：

- 第一次握手由客户端发送，服务器收到之后，**服务器**就知道**客户端的发送能力**是正常的。
- 第二次握手由服务器发送，客户端收到之后，**客户端**就知道**服务器的接收和发送能力**是正常的，且**客户端**自身的**接收和发送能力**也是正常的。
- 第三次握手由客户端发送，服务器收到之后，**服务器**就知道**客户端的接收能力**是正常的。

由这个过程可知，如果少了第三次那么，服务器无法确认客户端的接收能力，所以三次握手是必须的。


## 四次挥手

### 过程
挥手顾名思义，就是再见了，即断开连接。

由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个  FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

- **第一次挥手**：客户端发送一个 FIN，用来关闭客户端到服务端的数据传送，客户端进入 FIN_WAIT_1 状态，即表示客户端告诉服务端我不会再发送数据了，不过此时**客户端还可以接收数据**。
- **第二次挥手**：服务端收到 FIN 后，发送一个 ACK 给客户端，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号），服务端进入 CLOSE_WAIT 状态。
- **第三次挥手**：服务端发送一个 FIN，用来关闭服务端到客户端的数据传送，服务端进入 LAST_ACK 状态。即告诉客户端，我的数据也发送完了，不会再给你发送数据了。
- **第四次挥手**：客户端收到 FIN 后，发送一个 ACK 给服务端，确认序号为收到序号+1，客户端进入 TIME_WAIT 状态；服务端收到 ACK 后，关闭连接，进入 CLOSED 状态。

:::tip
其中：FIN 标志位数置1，表示断开 TCP 连接。
:::

如图所示：

![image-20250121115342314](https://cos.coderjc.cn/blog/image-20250121115342314.png)

### 为什么需要四次才能关闭连接？
这是因为服务器在 LISTEN（监听）状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方 ACK 和 FIN 一般都会分开发送。

## 十一种状态名词解析​​​​​​​
```js
LISTEN：等待从任何远端TCP 和端口的连接请求。

SYN_SENT：发送完一个连接请求后等待一个匹配的连接请求。

SYN_RECEIVED：发送连接请求并且接收到匹配的连接请求以后等待连接请求确认。

ESTABLISHED：表示一个打开的连接，接收到的数据可以被投递给用户。连接的数据传输阶段的正常状态。

FIN_WAIT_1：等待远端TCP 的连接终止请求，或者等待之前发送的连接终止请求的确认。

FIN_WAIT_2：等待远端TCP 的连接终止请求。

CLOSE_WAIT：等待本地用户的连接终止请求。

CLOSING：等待远端TCP 的连接终止请求确认。

LAST_ACK：等待先前发送给远端TCP 的连接终止请求的确认（包括它字节的连接终止请求的确认）

TIME_WAIT：等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认。
TIME_WAIT 两个存在的理由：
          1.可靠的实现tcp全双工连接的终止；
          2.允许老的重复分节在网络中消逝。

CLOSED：不在连接状态（这是为方便描述假想的状态，实际不存在）
```
