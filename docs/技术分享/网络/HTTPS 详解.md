---
title: HTTPS 详解
---

# HTTPS 详解

## 为什么会有 HTTPS
时至今日，互联网已经成为生活不可缺失的一部分，我们经常浏览器访问各式各样的站点，有时候还会提示这是一个危险站点进行警告，那浏览器是如何判断这个站点是否安全呢？这就需要我们了解 HTTPS 协议了。

我们访问一个站点非常简单，通常只需要在浏览器的地址栏输入网址，然后回车，就可以浏览了，但是这个数据的流转远比我们想象的复杂，例如某一家公司的站点是处于四川，而用户的电脑在湖南，那么这个过程就可能经过若干个路由节点，而跨度如此大就很难保证数据的安全性，如果数据被窃听或者篡改，那么就会造成一些不可预测的后果。

而无法保证安全的原因是因为 HTTP 协议本身并不涉及安全问题，数据会直接以明文的方式传递，所以如果有人想监听或篡改数据，那么无须花费太大的力气就可以完成。

例如早先年间上网时，不知道你有没有遇到过，只要访问一个站点，就会出现各种狗皮膏药般的弹窗小广告，比如一刀999，而这是因为网络运营商在网站返回给用户的数据中插入了广告弹窗的代码数据。而这种情况也表明了极大的不安全性。

而当互联网的应用越广泛，传递的数据价值也越来越大的时候，便不得不为 HTTP 协议提供安全保证，而迈出第一步的就是**网景公司(NetScape)**，该公司在 1994 年在自己的浏览器中实现了对 HTTPS 协议的支持，其中 S(secure) 表示安全。

## HTTPS 中的 S 是如何实现的

那网景公司是如何实现 HTTPS 协议的呢？HTTP 协议不安全是因为数据是明文传输的，所以该公司实现的方法自然就是**加密**，先对数据进行加密在进行传输，而另一方收到数据后在解密进行使用，这样虽然数据的传输依旧跨度极大，但是攻击者拿到密文的数据却也无可奈何。

但是加密必须要需要密钥，加密者使用 **密钥A** 进行加密，那么解密者同样需要 **密钥A** 才能进行解密，而这加解密使用同样密钥的方式也被称之为**对称加密**。

那么浏览器如何与服务器确定同一个密钥就十分重要了，如果直接由其中一方生成，然后以明文的方式传递过去，那中间的攻击者自然也可以拦截到，而攻击者拥有了密钥，后续的加密也就毫无意义了。

而此时就引出了另外一个方法**非对称加密**，对称加密假解密使用同一个密钥，具有对称性，而非对称密钥中，密钥总是成对出现，分别称之为**公钥**和**私钥**，使用公钥加密的数据只能使用私钥进行解密，而使用私钥加密的数据只能使用公钥进行解密，具有**非对称性**。

如此，服务器只需要先将公钥发送给浏览器，浏览器在生成一个**随机数据**，然后使用收到的公钥对这个**随机数据**进行加密，在发送给服务器，服务器再用自己的私钥解密，这样操作之后，服务器和浏览器就都拥有了**一个同样的随机数据**，而这个**随机数据就可以作为对称加密的密钥**了。后续真正要传递的数据就可以使用这个密钥进行加解密。

在这个过程中，攻击者即使拦截到了服务器下发的公钥也是无济于事，因为公钥无法解析由公钥自身加密的数据，至此，数据的传输已经有了一定的安全性。这就是 HTTPS 协议中 S 实现的大致原理。

而这也是独立于 HTTP 的一套流程，也被称之为**安全套接字(Secure Socket Layer)**，简称为**SSL**，这个密钥协商的过程也被称之为**SSL 握手**。

## TLS
从 1994 年至 1996 年 SSL 分别经历了 1.0 2.0 3.0 的版本升级，而在 3.0 的基础上，互联网工程事务组 (IETF) 决定将其标准化。最终于 1999 年以 TLS 这个名称发布，**传输层安全协议(Transport Layer Security)**，简称为**TLS**。也因此很多人将 TLS1.0 看作为 SSL3.1，后面在大家的表述中这两个名字也经常混用。

而从 SSL 变为 TSL 的另一个**重大意义**则是，当时和 SSL 的缔造者网景打得火热的微软显得不那么 loser。后来 TSL 又经历了 1.0(1999) 1.1(2006) 1.2(2008) 1.3(2018) 的版本升级。升级的内容一般是对安全细节的改善。例如随着 MD5 和 SHA-1 逐渐丧失安全性，TSL1.2 升级的主要内容就包括淘汰这两种哈希函数，而使用 SHA-256 代替。

## 隐患

问题此时似乎已经得到了解决，但是似乎也就表示并没有解决，这里依然存在一个十分扎手的问题，如果攻击者在服务器传递给浏览器自己的公钥过程中把公钥拦截，然后把这个服务器下发的公钥替换为自己的公钥，然后再发送给浏览器，又当如何？

浏览器此时虽然收到了公钥，但是它无法知道这是已经被替换过的公钥，仍然使用这个公钥来进行加密后续作为对称加密的随机数据，然后进行发送。

此时攻击者会拦截这个发送的数据，然后使用自己的私钥进行解密，得到浏览器生成的随机数据(abc123...)，然后在使用之前拦截到服务器下发的公钥进行加密，再发送给服务器。

服务器再收到攻击者发送来的加密数据之后，使用自己的私钥进行解密，然后以这个随机数据(abc123...)作为**对称加密的密钥**对后续数据进行加密。如此一来，攻击者就拥有了浏览器和服务器之间的对称加密的密钥，实现了两头欺骗，则后续的数据传输也就毫无秘密可言了。如图所示：

![image-20250124120611983](https://cos.coderjc.cn/blog/image-20250124120611983.png)

## 解决隐患 - CA
上述隐患的根本原因在于**公钥并不能表明自己属于谁**，因此解决的方法就是让**公钥具备表名自己身份的能力**，而想达到这个目的，就需要引入第三方角色。

现在服务器除了自己的公钥之外，还需要把自己的域名、组织名、以及所申请的第三方机构名信息放在一起，形成一个数据集合，具体如图：

![image-20250124141651417](https://cos.coderjc.cn/blog/image-20250124141651417.png)

然后拿着这份数据去寻找第三方机构，该机构也有一个公私钥对，然后该机构用自己的私钥加密数据，得到一个**密文**，而这个密文又被称之为**签名**，然后把签名数据和原始数据集合放在一起，发送给服务器的管理员，而这就是所谓的 TLS 证书。因此这个第三方机构也被称之为**证书颁发机构(Certificate Authority)**，简称**CA**。

而现在服务器下发的就不再是一个单一的公钥，而是一个能够表名自己身份的证书，浏览器拿到这个证书之后，会先进行验证，而不是直接相信，检验的方法就是用 CA 机构公开的公钥对证书中的密文进行解密，如果解密的结果，和证书这个数据集合中的数据一致，则验证码成功。

如果是合法的，则会从证书中提取出服务器的公钥，加密随机数据在进行发送，然后浏览器与服务器协商出对称加密的密钥。反之，如果不合法则会弹出风险提示，警告你正在访问一个不安全的网站。

做到这一步，原则上来说，攻击者将没有可能进行任何欺骗的可能，攻击者拦截并篡改的目的视为了让浏览器和服务器在密钥协商时使用自己的公钥，所以如果现在攻击者拦截到服务器下发的证书之后，把其中的公钥替换为自己的，那么浏览器收到之后，解密签名得到的结果中公钥和被篡改后的证书中的公钥不一致，浏览器就会认为这个证书是不合法的，从而弹出风险提示。

就算攻击者在 CA 机构中也申请到了一张证书，并在拦截之后替换为自己的证书，这样虽然解密签名的结果和证书的数据集合中的数据一致了，但显然证书中的域名和浏览器正在访问的地址又对不上，这样也会导致浏览器认为这个证书是不合法的，从而弹出风险提示。

而在这套安全机制中， CA 机构的角色十分重要，如果此时 CA 机构错误的给攻击者颁发了一张域名和机构信息是被攻击站点，但是数据集合中的公钥是攻击者的证书，浏览器便无法识别出这个证书是不合法的，从而信任了这张证书，那么攻击者就可以实现两头欺骗了。

而有资格颁发证书的 CA 机构并不多，而系统或者浏览器一般都内置了信任的 CA 机构，只有这些机构颁发的证书才会被信任，从而进一步提高安全性。

## 证书透明 - CT
> 证书透明（Certificate Transparency）是 Google 提出的一个公开的日志系统，用于记录所有公开受信任的 SSL/TLS 证书的签发情况。证书透明性可以防止中间人攻击，并允许任何人审计证书的签发情况。

上面的方案好像已经解决了问题，但是在这个解决方案中，CA 机构占比太大，责任重大且权利过于集中，因此这种依靠信任建立的安全显得十分脆弱。而自 CA 机构面世的那天起，就面临者黑客入侵等风险，但是比起技术风险，更大的风险是非技术风险，证书的颁发往往依靠的是人，进行审核，但人在工作中难免会存在失误，而只要是在社会中的人，就难保不会存在腐败而收受贿赂为不法分子开方便之门。

总而言之，无条件信任 CA 机构是不可取的，因此隐患并未消失，只是隐藏的更深了一点。而这也表示出了 CA 机构所面临的困境，各方的利益和身处这些利益中的人永远是造成混乱局面的根本原因，而且是无法根除的顽疾。因此在 2013 年“棱镜门”事件爆发之后，提出了 CT 方案。CT 机制的具体实现细节比较复杂，这里简单描述一下。

在加入 CT 的安全机制下，要求 CA 机构每次颁发一个证书的时候，都要向一个**日志服务器**的角色提交证书的详情，日志服务器将其记录下来，同时向 CA 机构返回一个 **SCT** 数据，CA 将 SCT 数据加入到证书中，把这个携带 SCT 的证书颁发给站点服务器，在 TLS 握手的时候浏览器拿到了这份携带了 SCT 信息的证书，除了像之前那样验证证书本身之外，还需要向日志服务器验证 SCT。

日志服务器也有自己的公私钥对，而 SCT 中则包含被日志服务器私钥加密签名的数据，所以浏览器会使用日志服务器的公钥对 SCT 信息中的签名进行验签来确定证书的真实性，这看起来好像是重复进行了一个套娃，不具备实际意义的操作。为了实现 CA 证书的透明，又套壳了一层 CT 机制。CA 机构可以被篡改和颁发异常的证书，CT 绝对安全，不会颁发错误的 SCT 吗？

这也是 CT 机制需要解决的核心问题？答案就是**去中心化**。区块链给人们带来最大的技术就是任何中心化的节点都是不可信任的，不论如何的权威，只有将信任分配到每个利益相关方的手中，相互监督才能打破困境，日志服务器采用了区块链中常用的 **Merkle tree(默克尔树)** 来防止篡改。

默克尔树数据结构将证书的颁发记录按照产生的时间进行仅此排列，分别计算出每份证书的哈希值，然后将相邻的两个哈希值组合在一起，形成新的数据，然后在对这个数据进行哈希计算，再把这两相邻的哈希值组合在一起，周而复始，直至最后只有一个数据。而这最后一个数据被称之为**根哈希值**，这样只需要监督这个根哈希值，就能保证数据无法被私自篡改。结构如图：

![image-20250124155811811](https://cos.coderjc.cn/blog/image-20250124155811811.png)

有了 CT 机制之后，域名的拥有者和 CA 机构都成为了监视者，极大的保证了证书的安全性。一开始还可以选择不上报来逃避审查，但是从 2018 年开始有 chrome 和 Safari 浏览器进行牵头，各家浏览器都开始强迫执行证书中的 CT 检查。也就是现在一个证书如果不懈怠 SCT 信息则会被浏览器视为不安全的站点。如此所有的 CA 机构都被强制加入监管。

截止到目前，加入 CT 机制的 TLS 证书基本上算是完美的解决方案。但和大多数安全领域的问题一样，完美就是像极限，只能无限趋近而无法真正的达到。

## 参考
[Ele实验室-https技术鉴赏](https://www.bilibili.com/video/BV1uY4y1D7Ng)
