---
title: 编译器有话说
---

# 编译器有话说
> 在上一步，我们已经知道了编译器是如何处理 `var a = 2` 这句代码的。所以这一章节，我们继续来讲解编译器是如何处理 `var a = 2` 这句代码的。

## 了解 LHS 和 RHS
在解释引擎时如何代码之前，我们需要了解一些前置知识。编程领域中，LHS（Left-Hand Side）​​ 和 ​​RHS（Right-Hand Side）​​ 是描述变量查找机制的术语，尤其在 JavaScript 中的作用域查询中至关重要。

### LHS（左侧查询）
- **目的**：找到变量的 **容器本身**（即赋值目标）
- **场景**：当变量出现在赋值操作的左侧时（a = 2），或函数传参（如 foo(a) 中的形参 a 接收值）
- **未声明时的行为**：
    - 非严格模式：当变量未声明时，LHS 会自动创建一个 **全局变量**
    - 严格模式：抛出 ReferenceError 异常

### RHS（右侧查询）
- **目的**：获取变量的 **​​值**​​（取值源头）
- **场景**：当变量出现在赋值操作的右侧时（a = b 中的 b），或函数调用（如 foo(2) 中的 foo）
- **未声明时的行为**：直接抛出 ReferenceError 异常


## 初步判断
那么我们来看一下下面两句代码，分别都会有什么表现：
```javascript
console.log(a);

a = 2;
```
`console.log(a)` 这句代码中，变量 a 的引用是 RHS 的引用，因为这里需要去查找变量 a 的值，才能将值传递给 `console.log` 函数。

而 `a = 2` 这句代码中，变量 a 的引用就是 LHS 的引用，并不关心当前的值是什么，只是想为 `= 2` 这个赋值操作找到一个目标。

当然，赋值的操作不仅限于 = 赋值操作符的左侧或者右侧，还有其它几种形式，不过这个是最好理解的。

## 进一步判断
案例如下：
```javascript
function foo(a) {
    console.log(a);
}
foo(2);
```
不知道你可以看出这个例子中，发生了哪些 LHS 和 RHS 的引用吗？
- 我们来看到最后一行代码 `foo(2)`，这是一个函数的调用，而调用函数之前，最重要的就是找到函数 foo 的引用，所以这里就是 **RHS** 的引用。
- 当这个函数调用之后，就会将 2 作为参数传入，而传入的过程中，则会将 **实参2** 赋值给 **形参a** ，即相当于执行了 `a = 2` 这句代码，所以这里就是 **LHS** 的引用。
- 而执行 `console.log(a)` 这句代码时，同样存在需要注意的细节，比如我们会先找到 `console` 对象的引用，然后找到 `log` 方法的引用，最后将 `a` 作为参数传入，所以这里同样存在 **RHS** 的引用。而且不止一次，是三次。

所以最后，我们可以用一个表格来总结一下：
| 操作 | LHS | RHS |
| :--- | :--- | :--- |
| foo(2) | (a = 2) 参数赋值 | 找到 foo 函数的引用 |
| console.log(a) | null | 查找 console、log、a 的引用 |
| 次数统计 | 1 | 4 |

当然，有时候我们的函数声明时，可能写成这样 `var foo = function (a) { ... }`，那么这里的函数声明则会额外存在一次 LHS 引用。

也可能你会好奇，为什么没有 RHS 引用呢？因为函数声明时，已经将函数名作为变量名，换而言之，函数表达式就是一个 **​​直接量**，和 123、hello 类似。直接就被引擎解析了，无需查找变量。而 RHS 的核心逻辑是 **查找某个变量的值**，所以函数声明时，自然也就没有 RHS 引用了。



